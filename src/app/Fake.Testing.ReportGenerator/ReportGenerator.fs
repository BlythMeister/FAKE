namespace Fake.Testing

/// <summary>
/// Contains a task which can be used to run <a href="https://github.com/danielpalme/ReportGenerator">
/// ReportGenerator</a>, which converts XML reports generated by PartCover, OpenCover or NCover into a
/// readable report in various formats.
/// </summary>
///
/// <example>
/// <code lang="fsharp">
/// open Fake.Testing
///
/// Target.create "Generate Reports" (fun _ ->
///   !! "**/opencover.xml"
///   |> Seq.toList
///   |> ReportGenerator.generateReports (fun p -> { p with TargetDir = "c:/reports/" })
/// )
/// </code>
/// </example>
[<RequireQualifiedAccess>]
module ReportGenerator =

    open System
    open System.IO

    open Fake.Core
    open Fake.DotNet

    /// The type of the report to generate
    type ReportType =
        | Html
        | HtmlChart
        | HtmlInline
        | HtmlInline_AzurePipelines
        | HtmlInline_AzurePipelines_Dark
        | HtmlSummary
        | MHtml
        | PngChart
        | TextSummary
        | Xml
        | XmlSummary
        | Latex
        | LatexSummary
        | Badges
        | CsvSummary
        | Cobertura
        | TeamCitySummary
        | Clover
        | JsonSummary
        | Lcov
        | MarkdownSummary
        | SonarQube

    /// Logging verbosity passed to ReportGenerator
    type LogVerbosity =
        | Verbose = 0
        | Info = 1
        | Error = 2

    /// <summary>
    /// ReportGenerator parameters, for more details see <a href="https://github.com/danielpalme/ReportGenerator">
    /// this link</a>.
    /// </summary>
    type ReportGeneratorParams =
        {
          /// Tool type
          ToolType: ToolType
          /// (Required) Path to the ReportGenerator exe file.
          ExePath: string
          /// (Required) The directory where the generated report should be saved.
          TargetDir: string
          /// The output formats and scope.
          ReportTypes: ReportType list
          /// Optional directories which contain the corresponding source code.
          SourceDirs: string list
          /// Optional directory for storing persistent coverage information.
          /// Can be used in future reports to show coverage evolution.
          HistoryDir: string
          /// Optional list of assemblies that should be included or excluded
          /// in the report  e.g. <c>-Foo.Test</c> (default is <c>+*</c>)
          /// Exclusion filters take precedence over inclusion
          /// filters. Wildcards are allowed.
          Filters: string list
          /// Optional list of files that should be included or excluded
          /// in the report e.g. <c>-*.xaml.cs</c> or <c>+*.cs</c> (default is <c>+*</c>)
          /// Exclusion filters take precedence over inclusion
          /// filters. Wildcards are allowed.
          FileFilters: string list
          /// Optional list of classes that should be included or excluded
          /// in the report  e.g. <c>-*Tests</c> (default is <c>+*</c>)
          /// Exclusion filters take precedence over inclusion
          /// filters. Wildcards are allowed.
          ClassFilters: string list
          /// Optional tag or build version
          Tag: string option
          /// The verbosity level of the log messages.
          LogVerbosity: LogVerbosity
          /// The directory where the ReportGenerator process will be started.
          WorkingDir: string
          /// The timeout for the ReportGenerator process.
          TimeOut: TimeSpan }

    let private currentDirectory = Directory.GetCurrentDirectory()

    let internal toolPath toolName =
        let toolPath = ProcessUtils.tryFindLocalTool "TOOL" toolName [ currentDirectory ]

        match toolPath with
        | Some path -> path
        | None -> toolName

    /// ReportGenerator default parameters
    let private ReportGeneratorDefaultParams =
        { ToolType = ToolType.Create()
          ExePath = toolPath "ReportGenerator.exe"
          TargetDir = currentDirectory
          ReportTypes = [ ReportType.Html ]
          SourceDirs = []
          HistoryDir = null
          Filters = []
          FileFilters = []
          ClassFilters = []
          Tag = None
          LogVerbosity = LogVerbosity.Verbose
          WorkingDir = currentDirectory
          TimeOut = TimeSpan.FromMinutes 5. }

    /// Builds the report generator command line arguments and process from the given parameters and reports
    let internal createProcess setParams (reports: string seq) =
        let parameters = setParams ReportGeneratorDefaultParams
        let joinWithSemicolon (xs: string seq) = String.Join(";", xs)

        let yieldIfSome paramName (value: string option) =
            seq {
                match value with
                | None -> ()
                | Some v -> yield sprintf "-%s:%s" paramName v
            }

        let yieldIfNotEmpty paramName (value: string seq) =
            seq {
                match value |> Seq.toList with
                | [] -> ()
                | xs -> yield sprintf "-%s:%s" paramName (xs |> joinWithSemicolon)
            }

        let yieldIfNotNullOrEmpty paramName value =
            seq {
                if String.isNotNullOrEmpty value then
                    yield sprintf "-%s:%s" paramName value
            }

        let args =
            [ yield! reports |> yieldIfNotEmpty "reports"
              yield sprintf "-targetdir:%s" parameters.TargetDir

              yield!
                  parameters.ReportTypes
                  |> List.map (fun rt -> rt.ToString())
                  |> yieldIfNotEmpty "reporttypes"

              yield!
                  parameters.SourceDirs
                  |> yieldIfNotEmpty "sourcedirs"
              yield!
                  parameters.HistoryDir
                  |> yieldIfNotNullOrEmpty "historydir"
              yield!
                  parameters.Filters
                  |> yieldIfNotEmpty "assemblyfilters"
              yield!
                  parameters.ClassFilters
                  |> yieldIfNotEmpty "classfilters"
              yield!
                  parameters.FileFilters
                  |> yieldIfNotEmpty "filefilters"
              yield! parameters.Tag |> yieldIfSome "tag"
              yield sprintf "-verbosity:%s" (parameters.LogVerbosity.ToString()) ]
            |> Arguments.OfArgs

        CreateProcess.fromCommand (RawCommand(parameters.ExePath, args))
        |> CreateProcess.withToolType (parameters.ToolType.WithDefaultToolCommandName "reportgenerator")
        |> CreateProcess.withWorkingDirectory parameters.WorkingDir
        |> CreateProcess.ensureExitCode
        |> fun command ->
            Trace.trace command.CommandLine
            command

    /// <summary>
    /// Runs ReportGenerator on one or more coverage reports.
    /// </summary>
    /// 
    /// <param name="setParams">Function used to overwrite the default ReportGenerator parameters.</param>
    /// <param name="reports">Coverage reports.</param>
    ///
    /// <example>
    /// <code lang="fsharp">
    /// !! "**/opencover.xml"
    ///         |> Seq.toList
    ///         |> ReportGenerator.generateReports (fun p -> { p with TargetDir = "c:/reports/" })
    /// </code>
    /// </example> 
    let generateReports setParams (reports: string seq) =
        use __ = Trace.traceTask "ReportGenerator" "Generating reports"

        let list = reports |> Seq.toList

        match list with
        | [] -> Trace.trace "No reports given. Ignoring task"
        | reports ->
            reports
            |> createProcess setParams
            |> Proc.run
            |> ignore

        __.MarkSuccess()
